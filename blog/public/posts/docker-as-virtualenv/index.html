<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Docker, a replacement of Virtualenv for Python developement | Velan Salis</title>
<meta name="keywords" content="docker, python, virtualenv" />
<meta name="description" content="A post about using docker to improve the workflow related to python development">
<meta name="author" content="Velan Salis">
<link rel="canonical" href="https://0xv31an5a1i5.xyz/posts/docker-as-virtualenv/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css" integrity="sha256-yIlj/i15RiAA/Q&#43;xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://0xv31an5a1i5.xyz/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://0xv31an5a1i5.xyz/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://0xv31an5a1i5.xyz/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://0xv31an5a1i5.xyz/apple-touch-icon.png">
<link rel="mask-icon" href="https://0xv31an5a1i5.xyz/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.92.0" />
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Docker, a replacement of Virtualenv for Python developement" />
<meta property="og:description" content="A post about using docker to improve the workflow related to python development" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://0xv31an5a1i5.xyz/posts/docker-as-virtualenv/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-01-10T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2018-01-10T00:00:00&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Docker, a replacement of Virtualenv for Python developement"/>
<meta name="twitter:description" content="A post about using docker to improve the workflow related to python development"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://0xv31an5a1i5.xyz/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Docker, a replacement of Virtualenv for Python developement",
      "item": "https://0xv31an5a1i5.xyz/posts/docker-as-virtualenv/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Docker, a replacement of Virtualenv for Python developement",
  "name": "Docker, a replacement of Virtualenv for Python developement",
  "description": "A post about using docker to improve the workflow related to python development",
  "keywords": [
    "docker", "python", "virtualenv"
  ],
  "articleBody": "Docker! Sounds fancy and simple but trust me it has revolutionized how the tech industry builds, ships and deploys the applications lately. Docker is basically a mini-operating system where you build and run your applications which is totally isolated from the native operating system in your computer, and the same container can be deployed in the hosting platforms. If you are new to docker and want to learn more about its intricacies, i highly encourage you to go through the links given in the end of this article to learn more about it. So let’s get right in :)\nCreating a Dockerfile Dockerfile is the recipe of an image. Dockerfile specifies how your image should look like. However, we are not creating an image from the scratch. We will take the existing image and add our dependencies on top of that to create a customized image based on our requirements. You can setup the Dockerfile to either take the existing requirements.txt file and install dependencies from pip or install dependencies manually without requirements.txt. This is how the Dockerfile will look like in either of the situations.\n FROM python:3 RUN mkdir /usr/src/app WORKDIR /usr/src/app # Below two steps are valid only if you have # requirements.txt in the project folder COPY requirements.txt . RUN pip install -r requirements.txt # If there is no requirements.txt, # You can install individual packages as follows # RUN pip install  ...   FROM: The image that we are building has to be built in such a way that we take an existing image and add our own functionalities to it. So we are choosing an image with python 3.x since we are dealing with Python developement. However, You can choose any image or any version you want.\n  RUN: This will run a command inside the image. Since our image is a mini linux OS (usually debian distribution) we can run linux commands inside it. Here we run mkdir /usr/src/app which creates a working directory for our application to run. Which is not absolutely necessary since its automatically created in the next step. This step was a demonstration of how to run commands inside an image.\n  WORKDIR: This specifies the working directory of our image. After setting the WORKDIR, Any RUN, CMD, ENTRYPOINT, COPY and ADD commands we execute, will be executed inside the WORKDIR . In our case, its /usr/src/app .\n  COPY: This command will copy any file specified on the left before the space to the directory specified on the right of the space. In our case, we are copying requirements.txt from our project folder on the host to our WORKDIR /usr/src/app in the image And running pip install -r requirements.txt on /usr/src/app which will install and save all the pip dependencies inside the image.\n  If there is no requirements.txt, you can skip the COPY step and install pip dependencies by specifying the pip install command in the RUN section one after the other. And save the Dockerfile with the name Dockerfile\nWe successfully created a recipe of how our image should look like, now the next step is to build the image based on this recipe.\nBuilding from the Dockerfile Now since we are done with creating our recipe, we need to build our own image from the recipe. To build the image, the command is as follows\ndocker build -t python/pack .  docker build is the command that tells docker that we need to build our own image. -t python/pack is where we add our own name for the new docker image. we can also add tags to the image using -t python/pack:latest where latest is the tag for the image. (although latest is a default tag for any new image) . tells the docker to use the current directory in lookout for Dockerfile . If the Dockerfile lies in different directory, you can specify the path from where you would want to build the Dockerfile . Once the build is finished, you will have a Customized docker image based on your recipe, and you can check it by running docker images command in the shell. You should see an image called python/pack\nCreating a Container Containers are the place where we execute our programs by mounting our local volumes to the container volumes. From where you can access the packages and dependencies installed in the container meanwhile, persisting the data to the host system. Run the following command in bash\ndocker run --rm -it \\ -u $(id -u):$(id -g) \\ -v /etc/passwd:/etc/passwd \\ -v $(pwd):/usr/src/app \\ python/pack \\ bash  This creates a container based on the image python/pack where you can accesss your project files from the directory /usr/src/app and then you can execute the code as you would do in your host machine. Lets break this command down line-by-line:\n  docker run –rm -it : docker run tells the docker daemon that we want to create a new container, **-it **is where we run this container in the interactive mode. -i basically keeps the STDIN open and -t allocates a pseudo TTY. In simple words, -it is essential to open a bashshell inside the container, later. You can also use -d instead of -it which starts the container in detached mode, which starts the container in the background.\n  -u $(id -u):$(id -g) : It is not recommended to start a container as a root user. So we specify -u flag and then user ID $(id -u) and group ID $(id -g) to start a container as a regular user. Now we will have previliges over only that directory which is mounted to the container and not the entire container. This is the cleaner way of creating a container.\n  -v /etc/passwd:/etc/passwd: This -v argument mounts /etc/passwd of the host to /etc/passwd of the container. Otherwise the docker container can’t access the usernames and display I have no name! in the bash prompt. Mounting /etc/passwd solves this problem.\n  -v $(pwd):/usr/src/app: This -v argument mounts your project directory to /usr/src/app by doing which you can access your code in the project directory inside the docker container and the changes made inside the docker container will be available in the project directory (pwd prints the present working directory). So in simple words, this creates a shared space between the container and the host machine from where the host machine can access the packages and dependencies installed in the docker image.\n  python/pack: This is pretty straight-forward. This is where we mention, which image is the container will be based on. The resulting container will contain the architecture of the mentioned image.\n  bash: This is where we mention the command to be executed soon after the container is created. Since we want the bash prompt, we specify the command bash which opens a bash shell soon after the container is created.\n  By the end of this process, we will have a container which is built with the dependencies we need, sharing a same space as our project directory, totally isolated from out host machine. This is really useful since the dependencies are not installed in the host machine. The host machine only contains the project folder but it runs inside the customized container. Clean stuf !!\nExtras/Troubleshooting   Editing a Docker Image : Let’s say you have created a Docker image with 3 packages and now you want to install a new package to the already built image. You can do it by editing the imageDockerfile and running the same command docker build -t python/pack . and docker will make changes to the existing image from where the content of the Dockerfile has changed. To make these changes, it is important to note that Dockerfile is in the same folder as it was initially built. Because Docker daemon uses current Dockerfile folder as a build context and when changes to the Dockerfile is made, build context will be checked and from there the Image will be built.\n  Port Forwarding : Port forwarding is such a useful functionality inside docker container. Let’s say you are using Jupyter notebook inside your docker container and it exposes a port 8888. But it will be on the context of the container, and not on the host machine. So if you go to localhost:8888 in the host machine, it won’t work. So you map the host’s 8888 port to container’s 8888 port when creating the container and then you can access jupyter notebook by going to localhost:8888 on the host machine. You can map a port by adding -p 8888:8888 when creating the container where left side of the : is the port on the host and the right side is the port on the container.\n  Conclusion Docker is a revolutionary tech, there is no doubt about that. Once the developement is over, the developed project can be containerized and the container can be deployed in hosting platforms like Digital Ocean. Containers can be made to talk to each other and each container can be used as a microservice. The possibilities are endless. It depends on you how would use this tech to the fullest. Happy coding :)\nEssential Docker Commands  Pull Image from Dockerhub : docker pull  Build a Docker Image : docker build -t  Create Docker Container : docker run [-it/-d] --rm -u :-v :-p : List Running Container : docker ps List All Containers : docker ps -a List All Container ID’s : docker ps -aq Delete Single Container : docker rm  Delete All Docker Containers : docker rm $(docker ps -aq) List all Images : docker images List all Image ID’s : docker images -aq Delete single image : docker rmi  Delete all images : docker rmi $(docker images -aq) Start Interactive session with a container started in detached mode (-d) : docker exec -it  bash  Important Links   Installing Docker\n  Post Installation Steps\n  Dockerfile, full reference\n  Compose file reference\n  ",
  "wordCount" : "1662",
  "inLanguage": "en",
  "datePublished": "2018-01-10T00:00:00Z",
  "dateModified": "2018-01-10T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Velan Salis"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://0xv31an5a1i5.xyz/posts/docker-as-virtualenv/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Velan Salis",
    "logo": {
      "@type": "ImageObject",
      "url": "https://0xv31an5a1i5.xyz/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://0xv31an5a1i5.xyz/" accesskey="h" title="Velan Salis (Alt + H)">Velan Salis</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://0xv31an5a1i5.xyz/posts" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://0xv31an5a1i5.xyz/archive" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://0xv31an5a1i5.xyz/search" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Docker, a replacement of Virtualenv for Python developement
    </h1>
    <div class="post-description">
      A post about using docker to improve the workflow related to python development
    </div>
    <div class="post-meta"><span title='2018-01-10 00:00:00 +0000 UTC'>January 10, 2018</span>&nbsp;·&nbsp;Velan Salis

</div>
  </header> 
  <div class="post-content"><p>Docker! Sounds fancy and simple but trust me it has revolutionized how the tech industry builds, ships and deploys the applications lately. <strong>Docker</strong> is basically a mini-operating system where you build and run your applications which is totally isolated from the native operating system in your computer, and the same container can be deployed in the hosting platforms. If you are new to docker and want to learn more about its intricacies, i highly encourage you to go through the links given in the end of this article to learn more about it. So let’s get right in :)</p>
<h3 id="creating-a-dockerfile">Creating a Dockerfile<a hidden class="anchor" aria-hidden="true" href="#creating-a-dockerfile">#</a></h3>
<p>Dockerfile is the recipe of an image. Dockerfile specifies how your image should look like. However, we are not creating an image from the scratch. We will take the existing image and add our dependencies on top of that to create a customized image based on our requirements. You can setup the Dockerfile to either take the existing requirements.txt file and install dependencies from pip or install dependencies manually without requirements.txt. This is how the Dockerfile will look like in either of the situations.</p>
<pre tabindex="0"><code>    FROM python:3

    RUN mkdir /usr/src/app
    WORKDIR /usr/src/app

    # Below two steps are valid only if you have
    # requirements.txt in the project folder
    COPY requirements.txt .
    RUN pip install -r requirements.txt

    # If there is no requirements.txt,
    # You can install individual packages as follows
    # RUN pip install &lt;package-1&gt; &lt;package-2&gt;...&lt;package-n&gt;
</code></pre><ul>
<li>
<p>FROM: The image that we are building has to be built in such a way that we take an existing image and add our own functionalities to it. So we are choosing an image with python 3.x since we are dealing with Python developement. However, You can choose any image or any version you want.</p>
</li>
<li>
<p>RUN: This will run a command inside the image. Since our image is a mini linux OS (usually debian distribution) we can run linux commands inside it. Here we run mkdir /usr/src/app which creates a working directory for our application to run. Which is not absolutely necessary since its automatically created in the next step. This step was a demonstration of how to run commands inside an image.</p>
</li>
<li>
<p>WORKDIR: This specifies the working directory of our image. After setting the WORKDIR, Any RUN, CMD, ENTRYPOINT, COPY and ADD commands we execute, will be executed inside the WORKDIR . In our case, its /usr/src/app .</p>
</li>
<li>
<p>COPY: This command will copy any file specified on the left before the space to the directory specified on the right of the space. In our case, we are copying requirements.txt from our project folder on the host to our WORKDIR /usr/src/app in the image And running pip install -r requirements.txt on /usr/src/app which will install and save all the pip dependencies inside the image.</p>
</li>
</ul>
<p>If there is no requirements.txt, you can skip the COPY step and install pip dependencies by specifying the pip install <!-- raw HTML omitted --> command in the RUN section one after the other. And save the Dockerfile with the name Dockerfile</p>
<p>We successfully created a recipe of how our image should look like, now the next step is to build the image based on this recipe.</p>
<h3 id="building-from-the-dockerfile">Building from the Dockerfile<a hidden class="anchor" aria-hidden="true" href="#building-from-the-dockerfile">#</a></h3>
<p>Now since we are done with creating our recipe, we need to build our own image from the recipe. To build the image, the command is as follows</p>
<pre><code>docker build -t python/pack .
</code></pre>
<p><strong>docker build</strong> is the command that tells docker that we need to build our own image. <strong>-t python/pack</strong> is where we add our own name for the new docker image. we can also add tags to the image using -t python/pack:latest where latest is the tag for the image. (although latest is a default tag for any new image) <strong>.</strong> tells the docker to use the current directory in lookout for Dockerfile . If the Dockerfile lies in different directory, you can specify the path from where you would want to build the Dockerfile . Once the build is finished, you will have a Customized docker image based on your recipe, and you can check it by running docker images command in the shell. You should see an image called python/pack</p>
<h3 id="creating-a-container">Creating a Container<a hidden class="anchor" aria-hidden="true" href="#creating-a-container">#</a></h3>
<p>Containers are the place where we execute our programs by mounting our local volumes to the container volumes. From where you can access the packages and dependencies installed in the container meanwhile, persisting the data to the host system. Run the following command in bash</p>
<pre><code>docker run --rm -it \
-u $(id -u):$(id -g) \
-v /etc/passwd:/etc/passwd \
-v $(pwd):/usr/src/app \
python/pack \
bash
</code></pre>
<p>This creates a container based on the image python/pack where you can accesss your project files from the directory /usr/src/app and then you can execute the code as you would do in your host machine. Lets break this command down line-by-line:</p>
<ul>
<li>
<p>docker run &ndash;rm -it : docker run tells the docker daemon that we want to create a new container, **-it **is where we run this container in the interactive mode. -i basically keeps the STDIN open and -t allocates a pseudo TTY. In simple words, -it is essential to open a bashshell inside the container, later. You can also use <strong>-d</strong> instead of <strong>-it</strong> which starts the container in detached mode, which starts the container in the background.</p>
</li>
<li>
<p>-u $(id -u):$(id -g) : It is not recommended to start a container as a root user. So we specify -u flag and then user ID $(id -u) and group ID $(id -g) to start a container as a regular user. Now we will have previliges over only that directory which is mounted to the container and not the entire container. This is the cleaner way of creating a container.</p>
</li>
<li>
<p>-v /etc/passwd:/etc/passwd: This -v argument mounts /etc/passwd of the host to /etc/passwd of the container. Otherwise the docker container can’t access the usernames and display I have no name! in the bash prompt. Mounting /etc/passwd solves this problem.</p>
</li>
<li>
<p>-v $(pwd):/usr/src/app: This -v argument mounts your project directory to /usr/src/app by doing which you can access your code in the project directory inside the docker container and the changes made inside the docker container will be available in the project directory (pwd prints the present working directory). So in simple words, this creates a shared space between the container and the host machine from where the host machine can access the packages and dependencies installed in the docker image.</p>
</li>
<li>
<p>python/pack: This is pretty straight-forward. This is where we mention, which image is the container will be based on. The resulting container will contain the architecture of the mentioned image.</p>
</li>
<li>
<p>bash: This is where we mention the command to be executed soon after the container is created. Since we want the bash prompt, we specify the command bash which opens a bash shell soon after the container is created.</p>
</li>
</ul>
<p>By the end of this process, we will have a container which is built with the dependencies we need, sharing a same space as our project directory, totally isolated from out host machine. This is really useful since the dependencies are not installed in the host machine. The host machine only contains the project folder but it runs inside the customized container. Clean stuf !!</p>
<h3 id="extrastroubleshooting">Extras/Troubleshooting<a hidden class="anchor" aria-hidden="true" href="#extrastroubleshooting">#</a></h3>
<ul>
<li>
<p><strong>Editing a Docker Image :</strong> Let’s say you have created a Docker image with 3 packages and now you want to install a new package to the already built image. You can do it by editing the imageDockerfile and running the same command docker build -t python/pack . and docker will make changes to the existing image from where the content of the Dockerfile has changed. To make these changes, it is important to note that Dockerfile is in the same folder as it was initially built. Because Docker daemon uses current Dockerfile folder as a build context and when changes to the Dockerfile is made, build context will be checked and from there the Image will be built.</p>
</li>
<li>
<p><strong>Port Forwarding :</strong> Port forwarding is such a useful functionality inside docker container. Let’s say you are using Jupyter notebook inside your docker container and it exposes a port 8888. But it will be on the context of the container, and not on the host machine. So if you go to localhost:8888 in the host machine, it won’t work. So you map the host’s 8888 port to container’s 8888 port when creating the container and then you can access jupyter notebook by going to localhost:8888 on the host machine. You can map a port by adding -p 8888:8888 when creating the container where left side of the : is the port on the host and the right side is the port on the container.</p>
</li>
</ul>
<h3 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h3>
<p>Docker is a revolutionary tech, there is no doubt about that. Once the developement is over, the developed project can be containerized and the container can be deployed in hosting platforms like Digital Ocean. Containers can be made to talk to each other and each container can be used as a microservice. The possibilities are endless. It depends on you how would use this tech to the fullest. Happy coding :)</p>
<h3 id="essential-docker-commands">Essential Docker Commands<a hidden class="anchor" aria-hidden="true" href="#essential-docker-commands">#</a></h3>
<ul>
<li>Pull Image from Dockerhub : <code>docker pull &lt;image name&gt;</code></li>
<li>Build a Docker Image : <code>docker build -t &lt;image name&gt; &lt;path&gt;</code></li>
<li>Create Docker Container :
<code>docker run [-it/-d] --rm -u &lt;user id&gt;:&lt;group id&gt; -v &lt;host directory&gt;:&lt;container directory&gt; -p &lt;host port&gt;:&lt;container port&gt; &lt;image name&gt; &lt;initial command&gt;</code></li>
<li>List Running Container : <code>docker ps</code></li>
<li>List All Containers : <code>docker ps -a</code></li>
<li>List All Container ID&rsquo;s : <code>docker ps -aq</code></li>
<li>Delete Single Container : <code>docker rm &lt;container id&gt;</code></li>
<li>Delete All Docker Containers : <code>docker rm $(docker ps -aq)</code></li>
<li>List all Images : <code>docker images</code></li>
<li>List all Image ID&rsquo;s : <code>docker images -aq</code></li>
<li>Delete single image : <code>docker rmi &lt;image id&gt;</code></li>
<li>Delete all images : <code>docker rmi $(docker images -aq)</code></li>
<li>Start Interactive session with a container started in detached mode (-d) : <code>docker exec -it &lt;container_name&gt; bash</code></li>
</ul>
<h3 id="important-links">Important Links<a hidden class="anchor" aria-hidden="true" href="#important-links">#</a></h3>
<ul>
<li>
<p><a href="https://docs.docker.com/install/">Installing Docker</a></p>
</li>
<li>
<p><a href="https://docs.docker.com/install/linux/linux-postinstall/">Post Installation Steps</a></p>
</li>
<li>
<p><a href="https://docs.docker.com/engine/reference/builder/">Dockerfile, full reference</a></p>
</li>
<li>
<p><a href="https://docs.docker.com/compose/compose-file/">Compose file reference</a></p>
</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://0xv31an5a1i5.xyz/tags/docker/">docker</a></li>
      <li><a href="https://0xv31an5a1i5.xyz/tags/python/">python</a></li>
      <li><a href="https://0xv31an5a1i5.xyz/tags/virtualenv/">virtualenv</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://0xv31an5a1i5.xyz/">Velan Salis</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
